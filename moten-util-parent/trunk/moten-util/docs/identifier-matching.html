<html>
<HEAD>
    <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>
<body>
<h2>Identity Matching Function</h2>
<p>Mathematical description of a an identity matching function based
on identifiers having types with numeric strengths.</p>
<h3>Abstract</h3>
<p>The purpose of this function is to merge a new entity with a set
of entities according to certain principles. Merge in this case means
matching and merging the identifiers of the new entity with the set of
entities. The set of entities is really just a set of disjoint
identifier sets.</p>
<h3>Conventions</h3>
<p>&weierp;(S) is the set of all subsets of S (the <i>power set</i>
of S).</p>
<p>When a function f is defined e.g. f : P &rarr; Q assume an
additional implicit definition f: &weierp;(P) &rarr; &weierp;(Q) given
by f(X) = {f(x): x &isin; X}</p>
<h3>Identity Matching Function</h3>
<p>Define</p>
<p class="indent1">I = set of identifiers</p>
<p class="indent1">T = set of identifier types</p>
<p>Given</p>
<p class="indent1">t: I &rarr; T categorises an identifier
with an identifier type</p>
<p class="indent1">s: T &rarr; &real; associates an
identifier type with a strength value</p>
<p class="indent1">d: T &rarr; &real; (orders identifiers
deterministically when identifiers have the same strength s), where</p>
<p class="indent2">s(t<sub>1</sub>)=s(t<sub>2</sub>)
&rArr; d(t<sub>1</sub>) &ne; d(t<sub>2</sub>) and s(t<sub>1</sub>) &gt;
s(t<sub>2</sub>) &rArr; d(t<sub>1</sub>) &gt; d(t<sub>2</sub>)</p>
<p>Define</p>
<p class="indent1">c (conflicting identifiers) :
&weierp;(I) &rarr; &weierp(I) given by</p>
<p class="indent2">c(X,Y) = {x : x &isin; X and t(x)
&isin; t(Y) but x &notin; Y}</p>
<p class="indent1">V (valid identifier sets) = {X : X
&sub; I and c(X,X) = &empty;}</p>
<p>Given</p>
<p class="indent1">&alpha;:I &rarr; V where</p>
<p class="indent2">&forall; x,y &isin; I, &alpha;(x) &cap;
&alpha;(y) &ne; &empty; &hArr; x=y</p>
<p class="indent1">time: &weierp;(I) &rarr; &real; is the
time property of an identifier set</p>


<p>Define</p>
<p class="indent1">d<sub>max</sub> : &weierp;(I) &rarr;
&real; given by</p>
<p class="indent2">d<sub>max</sub>(X) = max(d(i) : i&isin;
X)</p>
<p class="indent1">nms (non-matching stronger) :
&weierp;(I) X &weierp;(I) &rarr; &weierp(I) given by</p>
<p class="indent2">nms(X,Y) = { i&isin; X :
i&notin;Y and s(t(i)) >s(t(Y))}</p>
<p class="indent1">pm (primary match) : &weierp;(I) &rarr;
&weierp;(I) given by</p>
<p class="indent2">pm(X) = &empty; if &alpha;(x) = &empty; otherwise Y where Y &isin; &alpha;(X) and
d<sub>max</sub>(Y) = max( d<sub>max</sub>(Z) : Z &isin; &alpha;(X) }</p>

<p class="indent3">TODO prove pm returns unique values.</p>

<p>Finally,</p>
<p class="indent1">define merge : V &#x2a2f; I &rarr; V by</p>
<p class="indent2">merge(A, x) =</p>
<p class="indent3">For x &isin; A</p>
<table class="table4">
	<tr>
		<td>A</td>
		<td>if pm(A) = &empty;</td>
	</tr>
	<tr>
		<td>nms(A, pm(A))</td>
		<td>otherwise if x &isin; nms(A, pm(A))</td>
	</tr>
	<tr>
		<td>pm(A)</td>
		<td>otherwise if &alpha;(x) = pm(A)</td>
	</tr>
	<tr>
		<td>
		<p>(pm(A) &cup; Z )\{i : i &isin; pm(A) and t(i) &isin; t(Z)}
		where</p>
		<p class="indent1">Z = { i&isin; &alpha;(x) : i &notin;
		c(&alpha;(x),pm(A)) or time(&alpha;(x)) < time(A)}</p>
		</td>
		<td>otherwise if d(t(x)) = d<sub>max</sub>(&alpha;(x))</td>
	</tr>
	<tr>
		<td>(pm(A) &cup; {x})\{i : i &isin; pm(A) and t(i)=t(x)}</td>
		<td>otherwise if time(A) &gt; time(&alpha;(x))</td>
	</tr>
	<tr>
		<td>pm(A)</td>
		<td>otherwise</td>
	</tr>
</table>
<p class="indent3">For x &notin; A</p>
<table class="table4">
<tr><td>&empty;</td><td>A = &empty;</td></tr>
<tr><td>&alpha;(x) \ merge(A,A)</td><td>A &ne; &empty;</td></tr>
</table>
</body>
</html>
<html>
<HEAD>
<LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>
<body>
<h2>Identifier Matching Function</h2>
<p>Mathematical description of a an identifier matching function
based on identifiers with types that are comparable.</p>
<h3>Abstract</h3>
<p>A set of entities with non-conflicting identities is represented
by a set of disjoint identifier sets. Each identifier set has an
associated time. The problem is to define a function that takes a new
set of identifiers representing an update on one entity with it's
associated time and merges it with the existing entity set.</p>

<p>If the new identifiers do not exist in the entity set then a new
entity is created with those entities. If one or more of the new
identifiers do exist in the entity set (possibly against multiple
entities) then merge decisions need to be made.</p>

<p>Find a primary match to the set. Apply all identifiers to that
primary match, replacing identifiers of the same type if the new
identifiers time is greater than the primary match time.</p>

<p>Now take the resultant changed primary match and apply a merge
function with every identifier set that has a common identifier with it.
</p>
<p>The merge function will accept two identifier sets. If the second
set is stronger than the first set return the empty set. Otherwise, for
every identifier in the second identifier set add the identifier to the
first set if the identifier type does not exist in the first. If the
identifier type does exist in the first then replace the
identifier in the first set with the identifier type with the second
identifier iff the second timestamp is after the first time.
Reversing the parameters will return the adjusted secondary matching
identifier set.</p>

<h3>Conventions</h3>
<p>Capital variable names are used for sets, lower case variable
names are used for numbers.</p>
<p>When a function f is defined e.g. f : P &rarr; Q assume an
additional implicit definition f: &weierp;(P) &rarr; &weierp;(Q) given
by f(X) = {f(x): x &isin; X}</p>
<h3>Identifier Matching Function</h3>
<p>Define</p>
<p class="indent1">I = set of identifiers</p>
<p class="indent1">T = set of identifier types</p>
<p>Given</p>
<p class="indent1">t: I &rarr; T categorises an identifier with an
identifier type</p>
<p class="indent1">&gt : TxT &rarr; <b>B</b> is an infix comparator
of the strength of identifier types</p>
<p class="indent1">&gt;&gt; : TxT &rarr; <b>B</b> is an infix
comparator of the order of identifier types where</p>
<p class="indent3">&forall;s,t&isin;T, (s !&gt; t and t !&gt; s)
&hArr; s = t, s &gt; t &rArr; s &gt;&gt; t</p>
<p>Define</p>
<p class="indent1">c (conflicting identifiers) : &weierp;(I) &rarr;
&weierp;(I) given by</p>
<p class="indent2">c(X,Y) = {x &isin; X : t(x) &isin; t(Y) and x
&notin; Y}</p>
<p class="indent1">V (valid identifier sets) = { X &sub; I : c(X,X)
= &empty;}</p>
<p>Given</p>
<p class="indent1">&alpha;:I &rarr; V where</p>
<p class="indent2">x &isin; &alpha;(x) and &forall; x,y &isin; I,
&alpha;(x) &cap; &alpha;(y) &ne; &empty; &hArr; x=y</p>
<p class="indent1">time: V &rarr; &real; is the time property of an
identifier set</p>


<p>Define</p>
<p class="indent1">nms (non-matching stronger) : V &#x2a2f; V &rarr;
V given by</p>
<p class="indent2">nms(X,Y) = { i&isin; X : i&notin;Y and t(i) &gt;
t(y) &forall; y&isin;Y}</p>
<p class="indent1">pm (primary match) : V &rarr; V given by</p>
<p class="indent2">pm(X) = &empty; if &alpha;(X) = {&empty;}</p>
<p class="indent4">otherwise Y where Y &isin; &alpha;(X) and (max
(t((Y))) using >>) >> t &isin; Z &forall; Z&isin;&alpha;(X) and Z &ne; Y</p>

<p class="indent3">TODO prove pm is one-to-one</p>

<p>Define &beta; : V &#x2a2f; I &rarr; V by</p>
<p class="indent1">&beta;(A, x) =</p>
<p class="indent2">For x &isin; A</p>
<table class="table4">
	<tr>
		<td>A</td>
		<td>, if pm(A) = &empty;</td>
	</tr>
	<tr>
		<td>nms(A, pm(A))</td>
		<td>, if x &isin; nms(A, pm(A))</td>
	</tr>
	<tr>
		<td>pm(A)</td>
		<td>, if &alpha;(x) = pm(A)</td>
	</tr>
	<tr>
		<td>
		<p>(pm(A) &cup; Z )\{ i &isin; pm(A) : t(i) &isin; t(Z)} where</p>
		<p class="indent1">Z = { i &isin; &alpha;(x) : i &notin;
		c(&alpha;(x),pm(A)) or time(&alpha;(x)) < time(A)}</p>
		</td>
		<td>, if d(t(x)) = d<sub>max</sub>(&alpha;(x))</td>
	</tr>
	<tr>
		<td>(pm(A) &cup; {x})\{i &isin; pm(A) : t(i)=t(x)}</td>
		<td>, if time(A) &gt; time(&alpha;(x))</td>
	</tr>
	<tr>
		<td>pm(A) &cup; {x}</td>
		<td>, if &alpha;(x) = &empty;</td>
	</tr>
	<tr>
		<td>pm(A)</td>
		<td>, otherwise</td>
	</tr>
</table>
<p class="indent3">For x &notin; A</p>
<table class="table4">
	<tr>
		<td>&empty;</td>
	</tr>
</table>
<p>Define R : V &rarr; V by</p>
<p class="indent1">R(A)= &cup; &beta;(A,y) over y &isin; A</p>
<p>Finally define &alpha;':V &#x2a2f; I &rarr; V by</p>
<p class="indent1">For x &isin; A</p>
<p class="indent2">&alpha;'(A,x) = R(A)</p>
<p class="indent1">For x &notin; A</p>
<p class="indent2">&alpha;'(A,x) = &alpha;(x)\R(A)</p>
</body>
</html>